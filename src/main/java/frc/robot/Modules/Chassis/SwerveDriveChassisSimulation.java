package frc.robot.Modules.Chassis;

import frc.robot.Modules.PositionReader.PositionEstimatorSimulation;
import frc.robot.Modules.PositionReader.RobotFieldPositionEstimator;
import frc.robot.Utils.CollisionDetectionGrid;
import frc.robot.Utils.EasyDataFlow;
import frc.robot.Utils.MathUtils.AngleUtils;
import frc.robot.Utils.MathUtils.LookUpTable;
import frc.robot.Utils.MathUtils.Rotation2D;
import frc.robot.Utils.MathUtils.Vector2D;
import frc.robot.Utils.RobotConfigReader;
import frc.robot.Utils.RobotModuleOperatorMarker;

public class SwerveDriveChassisSimulation extends SwerveDriveChassisLogic {
    private final PositionEstimatorSimulation positionEstimatorSimulation;
    private final CollisionDetectionGrid collisionDetectionGrid = new CollisionDetectionGrid();
    public SwerveDriveChassisSimulation(SwerveWheelLogic frontLeft, SwerveWheelLogic frontRight, SwerveWheelLogic backLeft, SwerveWheelLogic backRight, PositionEstimatorSimulation positionEstimatorSimulation, RobotConfigReader robotConfig) {

        super(frontLeft, frontRight, backLeft, backRight, positionEstimatorSimulation, robotConfig);
        this.positionEstimatorSimulation = positionEstimatorSimulation;
    }

    @Override
    public double getChassisHeading() {
        return super.positionEstimator.getRobotRotation();
    }

    @Override
    public void setTranslationalTask(ChassisTaskTranslation translationalTask, RobotModuleOperatorMarker operator) {
        super.setTranslationalTask(translationalTask, operator);
    }

    @Override
    public void setRotationalTask(ChassisTaskRotation rotationalTask, RobotModuleOperatorMarker operator) {
        super.setRotationalTask(rotationalTask, operator);
    }

    @Override
    public void setChassisLocked(boolean locked, RobotModuleOperatorMarker operator) {

    }

    @Override
    public void setOrientationMode(OrientationMode mode, RobotModuleOperatorMarker operator) {

    }

    @Override
    public void setLowSpeedModeEnabled(boolean enabled, RobotModuleOperatorMarker operator) {

    }

    @Override
    public boolean isCurrentTranslationalTaskFinished() {
        return false;
    }

    @Override
    public boolean isCurrentRotationalTaskFinished() {
        return false;
    }

    @Override
    public void resetChassisPositionAndRotation() {

    }

    private double
            /* the maximum chassis speed when the chassis is doing sharp turn */
            robotMaximumSpeedAtSharpTurn,
            /* the maximum linear acceleration generated by the motors */
            maxLinearAcceleration,
            /* the maximum centripetal acceleration that te  */
            maxCentripetalAcceleration,
            /* the amount of friction, in acceleration, that the chassis experiences */
            friction,
            /* the maximum angular velocity of the chassis */
            maxAngularVelocity;
    @Override
    public void updateConfigs() {
        super.updateConfigs();
        robotMaximumSpeedAtSharpTurn = robotConfig.getConfig("chassis", "robotSpeedConstrainAtSharpTurn");
        maxLinearAcceleration = robotConfig.getConfig("chassis", "motorMaximumLinearAcceleration");
        maxCentripetalAcceleration = robotConfig.getConfig("chassis", "robotMaximumCentripetalAcceleration");
        friction = robotConfig.getConfig("chassis", "simulationFriction");
        maxAngularVelocity = Math.toRadians(robotConfig.getConfig("chassis", "robotMaxAngularVelocity"));
    }

    @Override
    protected void periodic(double dt) {
        /* run swerve wheel simulation to simulate the behaviors of swerve wheels */
        driveWheelsSafeLogic(translationalTask.translationValue, rotationalTask.rotationalValue);

        /* simulate chassis translation behavior */
        switch (translationalTask.taskType) {
            case SET_VELOCITY -> simulateChassisBehaviorSetVelocity(dt);
            case GO_TO_POSITION -> simulateChassisBehaviorGoToPosition(dt);
        }
        /* simulate chassis rotation behavior */
        switch (rotationalTask.taskType) {
            case SET_VELOCITY -> simulateChassisBehaviorSetRotationalVelocity(dt);
            case FACE_DIRECTION -> simulateChassisBehaviorFaceDirection(dt);
        }

        /* simulate the swerve actual status from chassis motion */
        if (super.positionEstimator.getRobotVelocity2D().getMagnitude() != 0 && super.positionEstimator.getRobotRotationalVelocity() != 0)
            EasyDataFlow.putSwerveState(
                    "actual swerve state",
                    frontLeft.calculateWheelMotion(positionEstimator.getRobotVelocity2D(), positionEstimator.getRobotRotationalVelocity()),
                    frontRight.calculateWheelMotion(positionEstimator.getRobotVelocity2D(), positionEstimator.getRobotRotationalVelocity()),
                    backLeft.calculateWheelMotion(positionEstimator.getRobotVelocity2D(), positionEstimator.getRobotRotationalVelocity()),
                    backRight.calculateWheelMotion(positionEstimator.getRobotVelocity2D(), positionEstimator.getRobotRotationalVelocity()),
                    positionEstimator.getRobotRotation2D()
            );
        else
            EasyDataFlow.putSwerveState(
                    "actual swerve state",
                    0, frontLeft.decideModuleDrivingDirection(),
                    0, frontRight.decideModuleDrivingDirection(),
                    0, backLeft.decideModuleDrivingDirection(),
                    0, backRight.decideModuleDrivingDirection(),
                    positionEstimator.getRobotRotation2D()
            );
        super.periodic(dt);
    }

    private void simulateChassisBehaviorGoToPosition(double dt) {
        // TODO simulate how the chassis will behave when asked to go to a position
    }

    private void simulateChassisBehaviorSetVelocity(double dt) {
        final Rotation2D pilotFacing = RobotFieldPositionEstimator.toActualRobotRotation(new Rotation2D(Math.toRadians(270)));
        final Vector2D desiredMotion =
                orientationMode == OrientationMode.FIELD ?
                        super.translationalTask.translationValue.multiplyBy(pilotFacing)
                        : super.translationalTask.translationValue.multiplyBy(new Rotation2D(positionEstimator.getRobotRotation() + Math.toRadians(90))),
                desiredVelocity = desiredMotion.multiplyBy(robotMaximumSpeed);
        
        Vector2D simulatedVelocity = positionEstimator.getRobotVelocity2D(), simulatedPosition = positionEstimator.getRobotPosition2D();

        double desiredSpeed = desiredVelocity.getMagnitude(),
                pilotStickDirection = desiredVelocity.getHeading();
        final boolean turnAround =
                Math.abs(AngleUtils.getActualDifference(simulatedVelocity.getHeading(), pilotStickDirection)) > Math.toRadians(120)
                        && simulatedVelocity.getMagnitude() != 0
                        && desiredSpeed != 0;
        if (turnAround) {
            pilotStickDirection = AngleUtils.simplifyAngle(pilotStickDirection + Math.PI);
            desiredSpeed *= -1;
        }

        final double
                minStepTime = 0.05,
                speedDifference = desiredSpeed - simulatedVelocity.getMagnitude(),
                linearAccelerationConstrain = speedDifference > 0 ?
                        LookUpTable.linearInterpretationWithBounding(0, maxLinearAcceleration * (desiredSpeed / robotMaximumSpeed), robotMaximumSpeed, 0, simulatedVelocity.getMagnitude())
                        : -LookUpTable.linearInterpretationWithBounding(0, friction, robotMaximumSpeed, 0, desiredSpeed),
                speedChange = linearAccelerationConstrain * dt,
                linearSpeedMinStep = Math.abs(linearAccelerationConstrain) * minStepTime,
                newSpeed = Math.abs(speedDifference) < linearSpeedMinStep ?
                        Math.abs(desiredSpeed) : simulatedVelocity.getMagnitude() + speedChange,

                desiredMotionDirection = desiredVelocity.getMagnitude() / robotMaximumSpeed < 0.03 ? simulatedVelocity.getHeading() : pilotStickDirection,
                headingDifference = AngleUtils.getActualDifference(simulatedVelocity.getHeading(), desiredMotionDirection),
                angularVelocityConstrain = maxCentripetalAcceleration / (1+simulatedVelocity.getMagnitude()),
                headingChange = Math.copySign(angularVelocityConstrain * dt, headingDifference),
                headingMinStep = angularVelocityConstrain * minStepTime,
                newHeading =
                        Math.abs(headingDifference) < headingMinStep || (simulatedVelocity.getMagnitude() / robotMaximumSpeed < 0.1) ?
                                desiredMotionDirection : AngleUtils.simplifyAngle(simulatedVelocity.getHeading() + headingChange);
        simulatedVelocity = new Vector2D(newHeading, newSpeed);

        final double currentMaximumSpeed =
                LookUpTable.linearInterpretationWithBounding(
                        0,
                        robotMaximumSpeed,
                        Math.toRadians(90),
                        robotMaximumSpeedAtSharpTurn,
                        Math.abs(AngleUtils.getActualDifference(simulatedVelocity.getHeading(), desiredVelocity.getHeading()))
                );
        simulatedVelocity = new Vector2D(newHeading, Math.min(currentMaximumSpeed, simulatedVelocity.getMagnitude()));

        if ((desiredVelocity.getMagnitude() == 0 || turnAround)
                && simulatedVelocity.getMagnitude() / robotMaximumSpeed < 0.1)
            simulatedVelocity = new Vector2D();
        EasyDataFlow.putNumber("chassis physics simulation", "dt", dt);
        EasyDataFlow.putNumber("chassis physics simulation", "speed difference", speedDifference);
        EasyDataFlow.putNumber("chassis physics simulation", "speed change", speedChange);
        EasyDataFlow.putNumber("chassis physics simulation", "pilot input mag", desiredVelocity.getMagnitude());
        EasyDataFlow.putNumber("chassis physics simulation",  "new speed", newSpeed);
        EasyDataFlow.putNumber("chassis physics simulation", "chassis max spd", currentMaximumSpeed);
        EasyDataFlow.putNumber("chassis physics simulation", "pilot stick dir", Math.toDegrees(pilotStickDirection));
        simulatedPosition = simulatedPosition.addBy(simulatedVelocity.multiplyBy(dt));

        // apply two times to prevent the robot from going through walls
        EasyDataFlow.putNumber("chassis physics simulation", "robot vel x unbounded", simulatedVelocity.getX());
        EasyDataFlow.putNumber("chassis physics simulation", "robot vel y unbounded", simulatedVelocity.getY());
        Vector2D[] pos_vel = collisionDetectionGrid.applyCollisionDetection(simulatedPosition, simulatedVelocity);
        simulatedPosition = pos_vel[0];
        simulatedVelocity = pos_vel[1];

        EasyDataFlow.putNumber("chassis physics simulation", "robot vel x", simulatedVelocity.getX());
        EasyDataFlow.putNumber("chassis physics simulation", "robot vel y", simulatedVelocity.getY());

        EasyDataFlow.putNumber("chassis physics simulation", "is in collision grid", collisionDetectionGrid.isInObstacle(simulatedPosition) ? 1 : 0);

        final Vector2D acceleration = Vector2D.displacementToTarget(positionEstimator.getRobotVelocity2D(), simulatedVelocity).multiplyBy(1.0/dt);
        positionEstimatorSimulation.updateRobotTranslationalStatus(simulatedPosition, simulatedVelocity, acceleration);
    }

    private void simulateChassisBehaviorFaceDirection(double dt) {
        // TODO simulate how the chassis will behave when asked to face a direction
    }

    private void simulateChassisBehaviorSetRotationalVelocity(double dt) {
        EasyDataFlow.putNumber("chassis physics simulation", "desired rotational speed", rotationalTask.rotationalValue * maxAngularVelocity);
        final double rotation = positionEstimator.getRobotRotation() +
                AngleUtils.simplifyAngle(rotationalTask.rotationalValue * dt * maxAngularVelocity);
        EasyDataFlow.putNumber("chassis physics simulation", "accumulated rotation (deg)", Math.toDegrees(rotation));
        positionEstimatorSimulation.updateRobotRotationalStatus(rotation, rotationalTask.rotationalValue * maxAngularVelocity);
    }

    @Override
    public void onReset() {
        super.onReset();
    }
}
